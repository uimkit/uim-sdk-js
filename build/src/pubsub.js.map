{"version":3,"file":"pubsub.js","sourceRoot":"","sources":["../../src/pubsub.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,cAAc,CAAA;AA8BpC,MAAM,CAAC,OAAO,OAAO,MAAM;IACzB,OAAO,CAAW;IAElB,YAAY,OAAsB;QAChC,IAAI,CAAC,OAAO,GAAG,IAAI,SAAS,CAAC,OAAO,CAAC,CAAA;IACvC,CAAC;IAED,KAAK,CAAC,OAAO,CACX,OAAe,EACf,OAAgB,EAChB,OAAwB;QAExB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,IAAI,CAAC,OAAO,CAAC,OAAO,CAClB,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,CAAC,OAAO,IAAI,EAAE,CAAC,EAAE,EACxC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;gBAChB,sBAAsB;gBACtB,IAAI,MAAM,CAAC,KAAK,EAAE;oBAChB,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,CAAA;iBAClC;qBAAM;oBACL,OAAO,EAAE,CAAA;iBACV;YACH,CAAC,CACF,CAAA;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,SAAS,CAAC,QAAuB,EAAE,OAA0B;QAC3D,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,GAAG,CAAC,OAAO,IAAI,EAAE,CAAC,EAAE,CAAC,CAAA;IAC1D,CAAC;IAED,WAAW,CAAC,QAAkB;QAC5B,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;YACvB,OAAO,EAAE,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE;gBAC1C,IAAI;oBACF,QAAQ,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;iBAClC;gBAAC,OAAO,CAAU,EAAE;oBACnB,sBAAsB;iBACvB;YACH,CAAC;SACF,CAAC,CAAA;IACJ,CAAC;CACF","sourcesContent":["import Webpubsub from \"webpubsub-js\"\n\nexport type PublishOptions = Omit<\n  Webpubsub.PublishParameters,\n  \"channel\" | \"message\"\n>\n\nexport type SubscribeOptions = Omit<\n  Webpubsub.SubscribeParameters,\n  \"channels\" | \"channelGroups\"\n>\n\nexport type Listener = (\n  channel: string,\n  message: unknown,\n  extra?: unknown\n) => void\n\nexport type PubSubOptions = Webpubsub.WebpubsubConfig\n\nexport interface SupportedPubSub {\n  publish: (\n    channel: string,\n    message: unknown,\n    options?: PublishOptions\n  ) => Promise<void>\n  subscribe: (channels: Array<string>, options?: SubscribeOptions) => void\n  addListener: (listener: Listener) => void\n}\n\nexport default class PubSub {\n  _client: Webpubsub\n\n  constructor(options: PubSubOptions) {\n    this._client = new Webpubsub(options)\n  }\n\n  async publish(\n    channel: string,\n    message: unknown,\n    options?: PublishOptions\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this._client.publish(\n        { channel, message, ...(options ?? {}) },\n        (status, _resp) => {\n          // TODO error handling\n          if (status.error) {\n            reject(status.errorData?.message)\n          } else {\n            resolve()\n          }\n        }\n      )\n    })\n  }\n\n  subscribe(channels: Array<string>, options?: SubscribeOptions): void {\n    this._client.subscribe({ channels, ...(options ?? {}) })\n  }\n\n  addListener(listener: Listener): void {\n    this._client.addListener({\n      message: ({ channel, message, ...extra }) => {\n        try {\n          listener(channel, message, extra)\n        } catch (e: unknown) {\n          // TODO error handling\n        }\n      },\n    })\n  }\n}\n"]}